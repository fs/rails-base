== Skeleton for new Rails 3 based application

This simple application includes ruby/rails technology which we use in the Flatsoft for new projects.
Application currently based on Rails 3 stable branch.

=== Gems

* Basic auth: Devise http://github.com/plataformatec/devise, app/models/user.rb
* Navigation: SimpleNavigation http://github.com/andi/simple-navigation, config/navigations
* DRY controllers: Inherited Resources, http://github.com/josevalim/inherited_resources
* Form builder: Formtastic http://github.com/justinfrench/formtastic, config/initializers/formtastic.rb
* List builder: Tabletastic http://github.com/jgdavey/tabletastic, config/initializers/tabletastic.rb
* Default styles for Formtastic: Flutie, github.com/thoughtbot/flutie
* Application config: Configatron, http://github.com/markbates/configatron, config/config.yml
* JS Framework: Jquery-rails, http://github.com/indirect/jquery-rails
* Tests: RSpec, Shoulda, RR, Cucumber, Factory Girl, Autotest
* Code metrics: rails_best_practices, http://github.com/flyerhzm/rails_best_practices

=== Initializers

* config.rb - loads configuration for current Rails environment to the configatron, so you can access them like configatron.app_name
* devise.rb - setup devise options, mailer_sender and pepper from config
* formtastic.rb - setup formtastic options
* tabletastic.rb -  setup tabletastic options, by default all actions rendered in the list
* mailer.rb - setup default hosts for mailer from configuration
* simple_navigation.rb - setup simplae navigation options
* time_formats.rb - setup default time formats, so you can use them like object.create_at.to_s(:us_time)

=== Quick start

* clone repository
* tune gemspec name in the .rvmrc
* tune config/config.yml
* tune in the sources application name: s/Rails3Base/YouApplicationName/g
* tune config/database.yml.example and copy it to the config/database.yml
* bundle install
* rake cucumber
* for autotest run in the shell "export AUTOFEATURE=true" and than run autotest command

=== Scaffolding

Scaffold generator will create: model with rspec, factory, controller based on inherited resources, views based on formtastic & tabletastic.

  $ rails g scaffold post title:string text:text

Cucumber:feature generator will create: cucumber feature for scaffold resource

  $ rails g cucumber:feature post title:string text:text

=== Tests

We use rspec with shoulda matchers for model testing and cucumber with capybara for integration testing.

==== Rspec

You should cover validations, associations with shoulda matchers and test deeply complected model methods.
Check out for example user_spec.rb

  describe User do
    it { should allow_mass_assignment_of(:full_name) }
    it { should allow_mass_assignment_of(:email) }
    it { should allow_mass_assignment_of(:password) }
    it { should allow_mass_assignment_of(:password_confirmation) }

    it { should validate_presence_of :full_name }
  end

==== Cucumber features

Try to use cucumber for hight level integration test, describe common logic and acceptance criteria.

Try to inherit low level steps in you custom steps related to the project.
For example better to write something like:
  When I submit valid post details
rather than
  When I fill in "Title" with "New title"
  And I fill in "Text" with "New text"
  And I press "Submit"

Use 'Background' to consolidate common steps in a feature:
  Background:
    Given I am an authenticated user


==== Cucumber steps

It's OK split steps by resources, for example features/step_defenitions/post_steps.rb for Post resource.
Use direct capybara calls in the steps:
  When /^I submit valid post details$/ do
    @new_post = Factory.build(:post)

    fill_in 'post_title', :with => @new_post.title
    fill_in 'user_text', :with => @new_post.text

    click_button 'post_submit'
  end

Try to use Factories as match as possible. For example if you have Post with different states like confirmed and unconfirmed it's good practice create two factories for this cases:
  Factory.define :post do |f|
    f.title 'How to write a good post'
    f.text 'Lorem ipsum?'
    f.confirmed true
  end

  Factory.define :unconfirmed_post, :parent => :post do |f|
    f.confirmed false
  end

And then use them in the steps:
  Given a post exists
  Given a unconfirmed post exists

These steps auto generated by factory girl.

=== Formtastic

If you have any difficulties with fortastic fill free to use standard form helpers.
But better to extend fortastic with custom field types.

  # lib/formtastic/money.rb
  module Formtastic
    module Money
      protected

      def money_input(method, options = {})
        html_options = { :size => 6 }.merge(options.delete(:input_html) || {})
        html_options = default_string_options(method, :string).merge(html_options)

        self.label(method, options_for_label(options)) <<
          template.content_tag(:span, '$', :class => 'char') <<
          self.text_field(method, html_options)
      end
    end
  end

  Formtastic::SemanticFormBuilder.send(:include, Formtastic::Money)

  # config/initialisers/formtastic.rb
  require 'formtastic/money'

  # in the view
  <%= form.input :price, :as => :money %>

=== Simple Navigation

Navigation configuration stored in the config/navigations folder.
We have main and user navigation which accessible for visitor and authorized user accordingly.


=== Note on Patches/Pull Requests

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send a pull request. Bonus points for topic branches.


=== How to update existing project with new changes from rails3-base repo

  git remote add rails3-base git://github.com/fs/rails3-base.git
  git checkout -b rails3-base-update
  git pull rails3-base master
  # fix conflicts
  # commit
  # test
  # merge

Thanks,
Flatsoft
